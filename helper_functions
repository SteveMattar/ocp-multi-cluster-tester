#!/bin/bash

### General Helpers Function ###

# Constants #

export RED='\x1b[0;31m'
export GREEN='\x1b[38;5;22m'
export CYAN='\x1b[36m'
export YELLOW='\x1b[33m'
export NO_COLOR='\x1b[0m'
export HAT="${RED}ðŸŽ©ï¸Ž${NO_COLOR}"

export TEMP_FILE="`mktemp`_temp"

export CONDA_ENV_NAME="conda-test"

shopt -s nocasematch # Case-insensitive match for string evaluations

set -o allexport # To export each function when it is declared, to be used on external bash processes

# Functions #

function print_cmd_location() {
  new_location="[$0] [${PWD##*/}]" && \
  if [[ "$new_location" != "$current_location" ]]; then
    export current_location="$new_location"
    echo -e "\n${CYAN}$current_location${NO_COLOR}\n"
  fi
  # Add PS1 prompt (and trim trailing and leading spaces)
  prompt=$(eval 'echo -e "\n'$PS1'\n"' | sed -e 's#\\\[##g' -e 's#\\\]##g' | xargs)
  prompt="${prompt:+"$prompt "}${1}"
  echo -e "${CYAN}${prompt}${NO_COLOR}"
}

# ------------------------------------------

# function debug_cmd_with_pipe() {
#   eval "$1"
# }

# Function to print each bash command before it is executed (using with "set -T" might have issues)
function trap_commands() {
  trap '
   if [[ ! "$BASH_COMMAND" =~ (echo|read|while|for|PROMPT|BUG|FATAL) ]] ; then
     cmd_escaped="$(echo -e "$BASH_COMMAND" | sed "s/\"/\\\\\"/g" 2>/dev/null)"
     cmd_eval=$(eval "echo -e \"$cmd_escaped\"" 2>/dev/null)
     if [[ -n $cmd_eval ]] ; then
       if [[ "$cmd_escaped" =~ \$\(.+\) ]] ; then
         cmd_to_print="${cmd_escaped}\n${cmd_eval}"
       else
         cmd_to_print="${cmd_eval}"
       fi
     else
       cmd_to_print="${cmd_escaped}"
     fi
     print_cmd_location "$cmd_to_print" || :
   fi
  ' DEBUG
}

export -f trap_commands
trap_commands

# ------------------------------------------

# Function to search rexexp in file (or pipe content),
# to Highlight matches and Return exit code (5 if no match found):
function highlight()
{
  # trap_commands
  pattern="$1"
  shift

  exit_code=0
  sed -r '/'"$pattern"'/,${s//'$YELLOW'&'$NO_COLOR'/g;b};$q5' "$@" || exit_code=$?
  if [[ "$exit_code" -eq 1 ]] ; then
    exit_code=0
    sed -e '/'"$pattern"'/,${s//'$YELLOW'&'$NO_COLOR'/g;b};$q5' "$@" || exit_code=$?
  fi
  echo
  return $exit_code
}

# ------------------------------------------

# function to watch for expected regex of command output, with retry attempts or timeout
function watch_and_retry() {
  # trap_commands
  # Command to execute and watch
  CMD="$1"
  # Optional: Number of retry attempts (default is 10)
  # If adding s/m to the number, it will be timeout in seconds/minutes
  RETRY="${2:-10}"
  # Optional: Pattern to search, otherwise expect $CMD exit 0
  REGEX="$3"
  # Max timeout for the whole watch process (default is 10 minutes)
  TIMEOUT=10m

  # If REGEX was specified - will wait for REGEX to be found in CMD output
  [[ -z "$REGEX" ]] || CMD="$CMD |& highlight '$REGEX'"

  #echo -e "# Watching output of command: $(eval echo \"$CMD\") \
  echo -e "# Watching output of command: $CMD \
  \n# Search pattern (or exit code): $REGEX"

  # Set timeout for the whole process, if RETRY is number of seconds/minutes (e.g. 20s or 3m)
  if [[ "$RETRY" =~ [0-9]+[sm] ]] ; then
    TIMEOUT=$RETRY
    RETRY=-1
  fi

  echo -e "# Retry attempts: $RETRY \
  \n# Timeout limit: $TIMEOUT"

  timeout $TIMEOUT bash <<EOF \
  || ( [[ $? -eq 124 ]] && echo "# Timeout of $TIMEOUT has exceeded." && return 1 )
    trap_commands ;
    COUNT=0 ;
    until eval "$CMD" || [[ \$COUNT -eq $RETRY ]] ; do
      printf "\$(( COUNT++ ))... " ;
      sleep 1 # A second interval ;
    done
    if [[ \$COUNT -eq $RETRY ]]; then
      echo "# Limit of $RETRY attempts has exceeded." ;
      exit 1 ;
    fi ;
    exit 0 ;
EOF
}

# ------------------------------------------

# Function to print current time and a message
function PROMPT() {
  message="$1"
  color="${2:-${YELLOW}}"
  cur_time="$HAT[$(date '+%Y-%m-%d %H:%M:%S')]"
  echo -e "\n${cur_time}\n"\
  "${color}### $message ###${NO_COLOR}\n"\
  "[${PWD}]\n"
}

# ------------------------------------------

# Function to print message about a potential bug/workaround, and an optional bug link
function FATAL() {
  failure_msg="${1}"
  echo -e "${RED}*** $failure_msg ***${NO_COLOR}"
  exit 2
}

# ------------------------------------------

# Function to print message about a potential bug/workaround, and an optional bug link
function BUG() {
  failed_action="${1}"
  workaround="${2}" # optional
  bug_ref="${3}" # optional

  echo -e "${RED}*** Known BUG ***\n Failure:${NO_COLOR} $failed_action"
  [[ -z "$workaround" ]] || echo -e "${RED} Workaround:${NO_COLOR} $workaround"
  [[ -z "$bug_ref" ]] || echo -e "${RED} Reference:${NO_COLOR} $bug_ref"
}

# ------------------------------------------

# Function to installing Anaconda (https://github.com/conda-forge)
function install_anaconda() {
  # trap_commands
  install_dir="$(echo "${1:-.}/miniconda" | tr -s /)" # Remove redundant slashes
  miniconda_bin_dir="${install_dir}/bin"
  [[ ":$PATH:" != *"/miniconda/bin:"* ]] && export PATH=${miniconda_bin_dir}:$PATH
  if ! conda info ; then
    echo "# Installing Anaconda"
    # rm -rf ${install_dir}
    # wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda.sh
    miniconda_installer="Miniconda3-latest-Linux-x86_64.sh"
    download_file https://repo.anaconda.com/miniconda/${miniconda_installer}
    chmod +x $miniconda_installer
    ./$miniconda_installer -b -u -p ${install_dir}
    conda update -y -n base -c defaults conda
    # conda clean -y --all
  fi

  # Remove old conda environment dir, if it is not configured
  env_dir=$(conda env list | awk -v name="$CONDA_ENV_NAME" '$0 ~ name { print $2 }')
  if [[ -z "$env_dir" ]] ; then
    echo "# Removing old Conda environment \"$CONDA_ENV_NAME\" directory (since it is not configured):"
    conda env remove -y -n $CONDA_ENV_NAME || :
    env_base=$(conda env list | awk '/base/ { print $NF }')
    rm -rf "$env_base/envs/$CONDA_ENV_NAME"
  fi

  echo "# Create Conda environment \"$CONDA_ENV_NAME\" (if it does not exists already)"
  [[ $(conda env list | grep "$CONDA_ENV_NAME") ]] || conda create -y -n $CONDA_ENV_NAME
}

# ------------------------------------------

function install_local_golang() {
  # Installing Golang with Anaconda (https://github.com/conda-forge/go-feedstock)
  trap_commands
  echo "# Installing a local Golang on user \"$(whoami)\" home directory, with Anaconda"

  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  # conda config --add channels defaults
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge go-nocgo_linux-64
  conda list
}

# ------------------------------------------

function verify_golang() {
  # Verify Golang installed.
  # Optional: $1 - GOBIN path
  echo "# Verifying Golang installation, and setting GOROOT, GOPATH, GOBIN, and GO111MODULE=on"
  go version || FATAL "No Golang installation found"

  # export GOROOT=/usr/local/go
  export GOROOT=$(go env GOROOT)

  # export GOPATH=~/go
  export GOPATH=$(go env GOPATH)

  # export GOBIN=$GOROOT/bin
  export GOBIN="${1:-$GOROOT/bin}"

  # export PATH=$PATH:$GOROOT/bin
  [[ ":$PATH:" != *":$GOBIN:"* ]] && export PATH=$GOBIN:$PATH

  export GO111MODULE=on

  # Print all GO env variables
  go env
}

# ------------------------------------------

function install_local_terraform() {
  # Installing Terraform with Anaconda (https://anaconda.org/conda-forge/terraform)
  # trap_commands
  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  echo "# Installing a local Terraform on user \"$(whoami)\" home directory, with Anaconda"
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge terraform
  conda list
}

# ------------------------------------------

# Docker with Anaconda is not supported in Linux yet
function install_local_docker() {
  # Installing Docker with Anaconda (https://anaconda.org/conda-forge/docker)
  # trap_commands
  # curl -o /etc/yum.repos.d/vbatts-shadow-utils-newxidmap-epel-7.repo \
  # https://copr.fedorainfracloud.org/coprs/vbatts/shadow-utils-newxidmap/repo/epel-7/vbatts-shadow-utils-newxidmap-epel-7.repo
  # yum install -y shadow-utils46-newxidmap
  # SKIP_IPTABLES=1 curl -fsSL https://get.docker.com/rootless | sh -s -- --experimental
  # # curl -fsSL https://get.docker.com/rootless | sh -s -- --iptables=false

  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  echo "# Installing a local Docker on user \"$(whoami)\" home directory, with Anaconda"
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge docker
  conda list
}

# ------------------------------------------

# Function to download file from URL, if local file doesn't exists, or has a different size on URL
function download_file() {
  # trap_commands
  # $1 => $source_file (download link)
  source_file="$1"

  # Optional: $2 => $target_file (where to save)
  target_file=${2:-$(basename "$1")}

  # Optional: $3 = Target FILE_NAME (and source_file is treated as Directory path)
  # if [[ -z "$3" ]]; then
  #   source_file="$1"
  #   FILE_NAME=$(basename "$1")
  # else
  #   source_file="$1/$3"
  #   FILE_NAME=$3
  # fi

  echo "# Downloading [$source_file] into $target_file"
  ls -ld

  local_file_size=$([[ -f ${target_file} ]] && wc -c < ${target_file} || echo "0")
  echo "local_file_size = $local_file_size"
  remote_file_size=$(curl -sI ${source_file} | awk '/Content-Length/ { print $2 }' | tr -d '\r' )
  echo "remote_file_size = $remote_file_size"
  [[ -n "$remote_file_size" ]] || remote_file_size=-1
  if [[ "$local_file_size" -ne "$remote_file_size" ]]; then
      echo "# Requested file was not downloaded yet, or remote file size is different. Downloading..."
      rm -rf "$target_file"
      if [[ $(which wget) ]] ; then
        target_dir=$(dirname -- "$target_file")
        wget "$source_file" --no-verbose --no-check-certificate --directory-prefix="$target_dir"
        source_file=$(basename -- "$source_file")
        mv "$target_dir/$source_file" "$target_file" || :
      else
        echo "# Wget is not installed, using Curl instead."
        curl -L "$source_file" -o "$target_file" --create-dirs
      fi
  else
    echo "# $target_file already downloaded, and equals to remote file $source_file"
  fi
}

# ------------------------------------------

# Function to delete files/directories which were not accessed N days (no recursive search in sub directories)
function delete_old_files_or_dirs() {
  # trap_commands
  # $1 => $wildcard_name
  wildcard_name="$1"

  # Optional: $2 => $dir_or_file. f=file, d=directory (default)
  dir_or_file="${2:-f}"

  # Optional: $3 => $access_days (5 default)
  access_days="${3:-5}"

  # Set $search_path as parent directory of $wildcard_name, if it includes slashes (current path by default)
  search_path=$(dirname -- "$wildcard_name")

  # Set $search_name as base directory of $wildcard_name, if it includes slashes
  search_name=$(basename -- "$wildcard_name")

  # find "$search_path"/* -maxdepth 0 -type $dir_or_file -name "$search_name" -atime +${access_days} -print -delete
  find "$search_path"/* -maxdepth 0 -type $dir_or_file -name "$search_name" -atime +${access_days} | xargs -n1 --verbose rm -rf
}

# ------------------------------------------

# Function to move non-empty directory to an existing directory
function backup_and_remove_dir() {
  # $1 => $src_dir
  src_dir="$1"

  # Optional: $2 => $dest_dir
  dest_dir="${2:-_$1}"

  if [[ ! -d ${src_dir} ]] || [[ -z `ls -A "$src_dir"` ]] ; then
    echo "# Source directory [${src_dir}] doesn't exist (or empty). Skipping backup"
  else
    echo "# Backup directory [${src_dir}] into [${dest_dir}]"

    # Make a new directory (skip if exists)
    mkdir -p "$dest_dir"

    # Copy * from src_dir to dest_dir (-afr : Keep attributes, Force overwrite, Recursive copy)
    cp -afr "${src_dir}"/. "${dest_dir}"/

    # Force remove old directory
    lsof +D "$src_dir" | awk '{print $2}' | tail -n +2 | xargs --no-run-if-empty kill -9
    rm -rf "$src_dir"
  fi
}

# ------------------------------------------

# Function to install aws-cli, and to configure AWS access:
function configure_aws_access() {
  AWS_PROFILE_NAME="$1"
  AWS_REGION="$2"
  AWS_KEY="$3"
  AWS_SECRET="$4"
  install_dir="${5:-./}"
  aws_bin_dir="${6:-$HOME/.local/bin}"

  PROMPT "Installing AWS-CLI, and setting Profile [$AWS_PROFILE_NAME] and Region [$AWS_REGION]"
  # pip install awscli --upgrade --user
  aws_cli_installer="awscli-exe-linux-x86_64.zip"
  download_file "https://awscli.amazonaws.com/${aws_cli_installer}" "${install_dir}/${aws_cli_installer}"
  unzip -n ${aws_cli_installer} -d ${install_dir}

  # export PATH=$HOME/.local/bin:$PATH
  # ${install_dir}/aws/install --update --install-dir ~/.local --bin-dir ~/.local/bin
  [[ ":$PATH:" != *":${aws_bin_dir}:"* ]] && export PATH="${PATH}:${aws_bin_dir}"
  ${install_dir}/aws/install --update --install-dir "${install_dir}/aws" --bin-dir "${aws_bin_dir}"

  aws --version

  aws configure set profile $AWS_PROFILE_NAME
  aws configure set aws_access_key_id $AWS_KEY
  aws configure set aws_secret_access_key $AWS_SECRET

  aws configure set default.region $AWS_REGION
  aws configure set output text
  aws configure set color on

  # aws --profile "$AWS_PROFILE_NAME" configure  --region "$AWS_REGION" --output text --color on
  aws sts get-caller-identity
}

# ------------------------------------------

# Function to create json file for a DNS record deletion on AWS
function create_json_for_dns_delete() {
  # Input $1 : File to write the json output to
  (
  cat <<EOF
  {
      "Comment": "Delete single record set",
      "Changes": [
          {
              "Action": "DELETE",
              "ResourceRecordSet": {
                  "Name": "$(echo ${Name/\\052/*})",
                  "Type": "$Type",
                  "AliasTarget": {
                    "HostedZoneId": "$HostedZoneId",
                    "DNSName": "$DNSName",
                    "EvaluateTargetHealth": $EvaluateTargetHealth
                    }}
                }]
    }
EOF
  ) > $1
}

# ------------------------------------------

# Function to export variables from json file as environment variables
function export_vars_from_json() {
  # Input $1 : Json file to read variables from
  for s in $(grep -E '": [^\{]' "$1" | sed -e 's/: /=/' -e 's/^\s*//' -e "s/\(\,\)$//"); do
    echo "# export $s"
    eval export $s
  done
}

# ------------------------------------------

# Function to delete an DNS record set in AWS Hosted Zone
function delete_aws_dns_records() {
  PROMPT "Deleting DNS record for AWS Cluster A (Public): $2"
  # trap_commands;
  # Input $1 : Hosted Zone ID
  # Input $2 : DNS record-set (name) to delete

  # export PATH=$HOME/.local/bin:$PATH
  # PATH="${PATH}:${aws_install_dir}/bin"

  echo -e "\n# Searching in Hosted Zone [$1] - for a DNS record set: [$2]"
  aws route53 list-resource-record-sets --hosted-zone-id $1 --query "ResourceRecordSets[?Name == '$2']" --out json > "$TEMP_FILE"

  cat $TEMP_FILE

  if [[ $(< $TEMP_FILE) == '[]' ]]; then
    echo -e "The DNS record set does not exist in AWS cluster [${CLUSTER_A_NAME}]"
    return
  fi

  echo -e "\n# Exporting DNS record set variables:"
  export_vars_from_json "$TEMP_FILE"

  echo -e "\n# Creating json file for the DNS record set delete command:"
  create_json_for_dns_delete "$TEMP_FILE"
  cat "$TEMP_FILE"

  echo -e "\n# Deleting the DNS record set:"
  aws route53 change-resource-record-sets --hosted-zone-id $1 --change-batch file://$TEMP_FILE

}

# ------------------------------------------

# Function to delete selcted namespace and CRDs on the current KUBECONFIG cluster
function delete_namespace_and_crds() {
  # trap_commands;
  # Input $1 : Namespace to delete
  # Input $2 - Optional : All CRDs to delete, by searching for *crd_name*
  ns_name=$1
  crd_name=$2
  delete_namespace=FALSE
  delete_crds=FALSE
  force_ns_delete=FALSE

  if [[ -n $crd_name ]] ; then
    echo "# Searching for existing CRDs of previous ${crd_name} installation on the cluster:"
    ${OC} get crds |& highlight "${crd_name}" && delete_crds=TRUE || :

    # If there are existing CRDs on the cluster - remove them all:
    # if [[ $? = 0 ]]; then
    if [[ "$delete_crds" = TRUE ]]; then
      echo "# Deleting ${crd_name} CRDs in the cluster"
      crd_list=$(${OC} get crds -o name | grep -Po "\/\K.*${crd_name}.*")
      # Ignoring hanged CRDs on delete, due to K8s bug: https://github.com/kubernetes/kubernetes/issues/60538
      ${OC} delete --timeout=10s crds $crd_list --ignore-not-found || : # || : to ignore none-zero exit code
          # customresourcedefinition.apiextensions.k8s.io "clusters.submariner.io" deleted
          # customresourcedefinition.apiextensions.k8s.io "endpoints.submariner.io" deleted
          # customresourcedefinition.apiextensions.k8s.io "submariners.submariner.io" deleted
    fi
  fi

    echo "# Searching for existing resources (and OLMs) in namespace ${ns_name} :"
    # ${OC} get all,olm --all-namespaces | grep --color "${crd_name}" || delete_namespace=FALSE
    ${OC} get all,olm -n ${ns_name} |& highlight "No resources found" || :

  # Removing whole namespace (and it's resources):
  if [[ ${ns_name} = "default" ]] ; then
    echo "# Skipping namespace deletion, since it's the \"default\" namespace."
    return
  else
    echo "# Deleting whole namespace ${ns_name} from the cluster"
    ${OC} delete --timeout=30s namespace ${ns_name} --ignore-not-found || force_ns_delete=TRUE

    if [[ "$force_ns_delete" = TRUE && $(${OC} get namespace ${ns_name}) ]]; then
      echo "# Warning: Force delete of namespace via API"
      ${OC} proxy &
      ${OC} get namespace ${ns_name} -o json | jq '.spec = {"finalizers":[]}' > temp.json
      curl -k -H "Content-Type: application/json" -X PUT --data-binary @temp.json 127.0.0.1:8001/api/v1/namespaces/${ns_name}/finalize
      kill -9 %% || :
      ${OC} delete namespace ${ns_name} --ignore-not-found --grace-period=0 --force --wait
    fi
  fi
}


# ------------------------------------------

# Function to install and expose Nginx service on the current KUBECONFIG cluster
function install_nginx_service() {
  trap_commands;

  ngnix_name="${1:-NginX}"
  target_namespace="${2}" # The Namespace on where Ngnix should be installed in
  nginx_image="nginxinc/nginx-unprivileged:stable-alpine"

  if [[ -n "$target_namespace" ]] ; then
    echo "# Create Namespace for Nginx: $target_namespace"
    # delete_namespace_and_crds "${target_namespace}"
    ${OC} create namespace "${target_namespace}" || echo "# Existing namespace \"${target_namespace}\" (ignore error)"
  fi

  echo "# Delete and create Nginx Deployment: $target_namespace (using Nginx image \"$nginx_image\")"
  ${OC} delete deployment ${ngnix_name} ${target_namespace:+-n $target_namespace} --ignore-not-found
  ${OC} create deployment ${ngnix_name} ${target_namespace:+-n $target_namespace} --image=$nginx_image

  echo "# Delete and expose Ngnix service on port 8080:"
  ${OC} delete service ${ngnix_name} ${target_namespace:+-n $target_namespace} --ignore-not-found
  ${OC} expose deployment ${ngnix_name} --port=8080 --name=${ngnix_name} ${target_namespace:+-n $target_namespace}

  echo "# Wait for Ngnix service to be ready:"
  ${OC} rollout status deployment ${ngnix_name} ${target_namespace:+-n $target_namespace}
  ${OC} describe pod ${ngnix_name} ${target_namespace:+-n $target_namespace}

}

# ------------------------------------------


#TODO: Use this function to upload E2E tests results to Polarion
function upload_test_results_polarion() {
  # Polarion Jump - update test results
    PROMPT "Polarion Jump - update test results"

  # git clone ssh://user@code.engineering.redhat.com/jump
  # cd jump
  # virtualenv venv
  # source venv/bin/activate
  # python -V
  # ./prepare_pylarion.sh
  # pip install colorlog
  #
  # To upload to this test:
  # https://polarion.engineering.redhat.com/polarion/#/project/RHELOpenStackPlatform/testrun?id=20190815-0853
  #
  # python jump.py --testrun-id="20190815-0853" --xml-file="junit__01.xml" --update_testcases=True --debug=True # --jenkins_build_url=\$BUILD_URL
  #
  # python jump.py --testrun-id="20181118-1147" --xml-file="junit__01.xml" --debug=True # --jenkins_build_url=\$BUILD_URL
  #
  # ./rhos-qe-jenkins/jobs/defaults/include/jump.groovy.inc
}

# ------------------------------------------

function log_to_html() {
  # trap_commands;
  log_file="$1"
  title="${2:-"${log_file%%.*}"}"
  html_output="${3:-${title// /_}.html}"

  echo "# Generating HTML report from: $log_file"
  [[ -f $log_file ]] || ( echo "# Error - The file does not exists, or is not accessible" && return 1 )
  repo_url=https://github.com/theZiz/aha.git
  repo_branch=0.5
  repo_dir=$(basename $repo_url .git)

  # Get AHA binary
  if [[ ! -f ./$repo_dir/aha ]]; then
      rm -rf $repo_dir
      # git clone --quiet --branch "$repo_branch" $repo_url > /dev/null
      git clone $repo_url --single-branch # --depth 1
      git --work-tree=$repo_dir  --git-dir=$repo_dir/.git checkout tags/$repo_branch
      make -C $repo_dir &> /dev/null
  fi
  ./$repo_dir/aha --version

  # Create HTML Header
  cat > "$html_output" <<EOF
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <meta http-equiv="Content-Type" content="application/xml+xhtml; charset=UTF-8; width=device-width; initial-scale=1" />
  <title>${title}</title>
  <style type="text/css">
  pre {white-space: pre-wrap; white-space: -moz-pre-wrap !important;
  white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;}
  .collapsible {
    background-color: LightSkyBlue;
    color: black;
    cursor: pointer;
    padding: 10px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 20px;
    -webkit-touch-callout: text;
    -webkit-user-select: text;
    -khtml-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
  }
  .active {
    background-color: RoyalBlue;
    color: white;
  }
  .collapsible:hover {
    background-color: RoyalBlue;
    color: white;
    text-decoration: underline;
  }
  .content {
    padding: 0 18px;
    display: none;
    overflow: hidden;
    background-color: LightSkyBlue;
  }
  </style>
  </head>
  <body style="background-color:LightSkyBlue">
  <h1>${title}</h1>
  <pre>
EOF

  # Trim empty lines (from top) and spaces (not tabs) from each line in the log file
  #sed '/\S/,$!d; s/^ \+//; s/ \+$//' -i $log_file
  sed '/\S/,$!d' -i $log_file

  # Create HTML content with AHA
  ./$repo_dir/aha -f $log_file --title "$title" --word-wrap --no-header >> $html_output

  # Replace all lines of "<span...### {text...} ###</span>" - with a collapsible span ("###" was created with "PROMPT" function)
  sed -r 's:<span.+###\s+:<button type="button" class="collapsible"><span>:g' -i $html_output
  sed -r 's:\s+###</span.+$:<\/span><\/button><div class="content">:g' -i $html_output

  # Close all collapsible spans, when getting to lines of ðŸŽ©ï¸Ž (excluding first time)
  sed -r 's:(.+ðŸŽ©ï¸Ž):<\/div><br><br>\1:g' -i $html_output
  sed '0,/<\/div><br><br>/s///' -i $html_output

  # Create HTML collapsible function (must be at the bottom)
  cat >> $html_output <<EOF
  </pre>
  <br><br><br>
  <script>
  var coll = document.getElementsByClassName("collapsible");
  var i;
  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
  </script>
  </body>
  </html>
EOF

  echo -e "HTML report created:\n$html_output"
}
