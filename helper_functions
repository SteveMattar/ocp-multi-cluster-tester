#!/bin/bash

### General Helpers Function ###

# Constants #

export RED='\x1b[0;31m'
export GREEN='\x1b[38;5;22m'
export CYAN='\x1b[36m'
export YELLOW='\x1b[33m'
export NO_COLOR='\x1b[0m'
export HAT="${RED}ðŸŽ©ï¸Ž${NO_COLOR}"

export CONDA_ENV_NAME="conda-test"

# Set SCRIPT_DIR as current absolute path where this script runs in
export SCRIPT_DIR="$(dirname "$(realpath -s $0)")"

# include shell2junit library
source "$SCRIPT_DIR/shell2junit/sh2ju.sh"

shopt -s nocasematch # Case-insensitive match for string evaluations

set -o allexport # To export each function when it is declared, to be used on external bash processes

# Functions #

function print_cmd_location() {
  new_location="[$0] [${PWD##*/}]" && \
  if [[ "$new_location" != "$current_location" ]]; then
    export current_location="$new_location"
    echo -e "\n${CYAN}$current_location${NO_COLOR}\n"
  fi
  # Add PS1 prompt (and trim trailing and leading spaces)
  prompt=$(eval 'echo -e "\n'$PS1'\n"' | sed -e 's#\\\[##g' -e 's#\\\]##g' | xargs)
  prompt="${prompt:+"$prompt "}${1}"
  echo -e "${CYAN}${prompt}${NO_COLOR}"
}

# ------------------------------------------

# Function to search and highlight rexexp in file (or pipe content)
function highlight()
{
  #trap_commands
  pattern="$1"
  file_input="$2"

  exit_code=0
  # 0 = Match found
  # 1 = SED execution error
  # 3 = Match not found
  # 4 = Empty string or file

  local tmp_file="`mktemp`_highlight"
  # Save all output to temp file
  #grep -E "$pattern|$" "$@" > $tmp_file
  grep -E "$pattern|$" ${file_input:+"$file_input"} > $tmp_file

  # Exit if file is empty or contains spaces only
  grep -q '[^[:space:]]' $tmp_file || return 4

  # Print with match colored
  # cat $tmp_file | grep --color -E "$pattern|$"

  # Search line for sed command. Highlighting pattern, if found
  search_line='/'"$pattern"'/,${s//'$YELLOW'&'$NO_COLOR'/g;b};$q3'

  # SED with -r : Basic regex
  sed -r "$search_line" $tmp_file || exit_code=$?

  # If SED had an error, try to search with -e : Extended regex"
  if [[ "$exit_code" -eq 1 ]] ; then
    exit_code=0
    sed -e "$search_line" $tmp_file || exit_code=$?
  fi

  # Return if match found
  # cat $tmp_file | grep -q -E "$pattern"
  return $exit_code
}

# ------------------------------------------

# function debug_cmd_with_pipe() {
#   eval "$1"
# }

# Function to print each bash command before it is executed (using with "set -T" might have issues)
function trap_commands() {
  trap '
   if [[ ! "$BASH_COMMAND" =~ (echo|read|while|for|PROMPT|BUG|FATAL) ]] ; then
     cmd_escaped="$(echo -e "$BASH_COMMAND" | sed "s/\"/\\\\\"/g" 2>/dev/null)"
     cmd_eval=$(eval "echo -e \"$cmd_escaped\"" 2>/dev/null)
     if [[ -n $cmd_eval ]] ; then
       if [[ "$cmd_escaped" =~ \$\(.+\) ]] ; then
         cmd_to_print="${cmd_escaped}\n${cmd_eval}"
       else
         cmd_to_print="${cmd_eval}"
       fi
     else
       cmd_to_print="${cmd_escaped}"
     fi
     print_cmd_location "$cmd_to_print" || :
   fi
  ' DEBUG
}

export -f trap_commands
trap_commands

# ------------------------------------------

# Function to trap test exit failure - to print more info before exiting main flow
function trap_function_on_error() {
  func_to_execute="$@"
  trap 'rc=$?; echo "# [$FUNCNAME[$@]] returned EXIT $rc:
  ${BASH_SOURCE[$i+1]}:$BASH_LINENO > ${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}"; \
  [[ "$rc" = "0" ]] || eval "$func_to_execute"' EXIT # ERR HUP INT TERM  # Trap any script termination (not just EXIT)
}

# ------------------------------------------

# function to watch for expected regex of command output, with retry attempts or timeout
function watch_and_retry() {
  # trap_commands
  # Command to execute and watch
  CMD="$1"
  # Optional: Number of retry attempts (default is 10)
  # If adding s/m to the number, it will be timeout in seconds/minutes
  RETRY="${2:-10}"
  # Optional: Pattern to search, otherwise expect $CMD exit 0
  REGEX="$3"
  # Max timeout for the whole watch process (default is 10 minutes)
  TIMEOUT=10m

  # If REGEX was specified - will wait for REGEX to be found in CMD output
  [[ -z "$REGEX" ]] || CMD="( $CMD ) | highlight '$REGEX'"

  #echo -e "# Watching output of command: $(eval echo \"$CMD\") \
  echo -e "# Watching output of command: $CMD \
  \n# Search pattern (or exit code): $REGEX"

  # Set timeout for the whole process, if RETRY is number of seconds/minutes (e.g. 20s or 3m)
  if [[ "$RETRY" =~ [0-9]+[sm] ]] ; then
    TIMEOUT=$RETRY
    RETRY=-1
  fi

  echo -e "# Retry attempts: $RETRY \
  \n# Timeout limit: $TIMEOUT"

  # To use timeout - must run command as an external script
  timeout $TIMEOUT bash <<EOF \
  || ( [[ $? -eq 124 ]] && echo "# Timeout of $TIMEOUT has exceeded." && return 1 )
    trap_commands ;
    COUNT=0 ;
    until $CMD || [[ \$COUNT -eq $RETRY ]] ; do
      printf "\$(( COUNT++ ))... " ;
      sleep 1 # A second interval ;
    done
    if [[ \$COUNT -eq $RETRY ]]; then
      echo "# Limit of $RETRY attempts has exceeded." ;
      exit 1 ;
    fi ;
    exit 0 ;
EOF
}

# ------------------------------------------

# Function to print current time and a message
function PROMPT() {
  message="$1"
  color="${2:-${YELLOW}}"
  cur_time="$HAT[$(date '+%Y-%m-%d %H:%M:%S' || :)]"
  echo -e "\n${cur_time}\n"\
  "${color}### $message ###${NO_COLOR}\n"\
  "[${PWD}]\n"
}

# ------------------------------------------

# Function to print message about a potential bug/workaround, and an optional bug link
function FATAL() {
  failure_msg="${1}"
  echo -e "\n${RED}*** Fatal error occurred *** \n $failure_msg ${NO_COLOR}" >&2
  # kill -s TERM $$
  # kill -s TERM $BASHPID
  kill -s EXIT $PPID
  exit 127
}

# ------------------------------------------

# Function to print message about a potential bug/workaround, and an optional bug link
function BUG() {
  failed_action="${1}"
  workaround="${2}" # optional
  bug_ref="${3}" # optional

  echo -e "${RED}****** BUG ******\n Failure:${NO_COLOR} $failed_action"
  [[ -z "$workaround" ]] || echo -e "${RED} Workaround:${NO_COLOR} $workaround"
  [[ -z "$bug_ref" ]] || echo -e "${RED} Reference:${NO_COLOR} $bug_ref"
}


# ------------------------------------------

# Function to run the command and records its output/error messages in junit format
# Ref: https://github.com/kubernetes/kubernetes/blob/master/test/cmd/legacy-script.sh
function record_junit() {
  # it expects the first to be the name of the command
  # Example:
  # record_junit function_name arg1 arg2
  #
  # WARNING: Variable changes in the command will NOT be effective after record_junit returns.
  #          This is because the command runs in subshell.

  # $1 => $output_file (file name without directory, to record junit results)
  local output_file="$1"

  # Shift arguments to the left ($1 gets lost), to save rest of args as array $@
  shift

  # $2 => $test_name (the function to run and record as junit test)
  local test_name="$1"

  local func_and_args="$@"

  #local output_dir=$(dirname "$0")
  local output_dir="$SCRIPT_DIR"

  # Set $junit_suite from current executing script filename
  local junit_suite=$(basename "${0%.*}")

  echo "# Recording junit test \"$test_name\" ${func_and_args:+[$func_and_args]}
  into xml output file \"${output_dir}/${output_file}\""

  # juLog -output="$output_dir" -file="$output_file" -index -class="$junit_suite" -name="$test_name" "$func_and_args"
  juLog -output="$output_dir" -file="$output_file" -class="$junit_suite" -name="$test_name" "$func_and_args"
}

# ------------------------------------------

# Function to installing Anaconda (https://github.com/conda-forge)
function install_anaconda() {
  # trap_commands
  install_dir="$(echo "${1:-.}/miniconda" | tr -s /)" # Remove redundant slashes
  miniconda_bin_dir="${install_dir}/bin"
  [[ ":$PATH:" != *"/miniconda/bin:"* ]] && export PATH=${miniconda_bin_dir}:$PATH
  if ! conda info ; then
    echo "# Installing Anaconda"
    # rm -rf ${install_dir}
    # wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda.sh
    miniconda_installer="Miniconda3-latest-Linux-x86_64.sh"
    download_file https://repo.anaconda.com/miniconda/${miniconda_installer}
    chmod +x $miniconda_installer
    ./$miniconda_installer -b -u -p ${install_dir}
    conda update -y -n base -c defaults conda
    # conda clean -y --all
    # conda clean -a
  fi

  # Remove old conda environment dir, if it is not configured
  env_dir=$(conda env list | awk -v name="$CONDA_ENV_NAME" '$0 ~ name { print $2 }')
  if [[ -z "$env_dir" ]] ; then
    echo "# Removing old Conda environment \"$CONDA_ENV_NAME\" directory (since it is not configured):"
    conda env remove -y -n $CONDA_ENV_NAME || :
    env_base=$(conda env list | awk '/base/ { print $NF }')
    rm -rf "$env_base/envs/$CONDA_ENV_NAME"
  fi

  echo "# Create Conda environment \"$CONDA_ENV_NAME\" (if it does not exists already)"
  [[ $(conda env list | grep "$CONDA_ENV_NAME") ]] || conda create -y -n $CONDA_ENV_NAME
}

# ------------------------------------------

function install_local_golang() {
  # Installing Golang with Anaconda (https://github.com/conda-forge/go-feedstock)
  trap_commands
  echo "# Installing a local Golang on user \"$(whoami)\" home directory, with Anaconda"

  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  # conda config --add channels defaults
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge go-nocgo_linux-64
  conda list
}

# ------------------------------------------

function verify_golang() {
  # Verify Golang installed.
  # Optional: $1 - GOBIN path
  echo "# Verifying Golang installation, and setting GOROOT, GOPATH, GOBIN, and GO111MODULE=on"
  go version || FATAL "No Golang installation found"

  # export GOROOT=/usr/local/go
  export GOROOT=$(go env GOROOT)

  # export GOPATH=~/go
  export GOPATH=$(go env GOPATH)

  # export GOBIN=$GOROOT/bin
  export GOBIN="${1:-$GOROOT/bin}"

  # export PATH=$PATH:$GOROOT/bin
  [[ ":$PATH:" != *":$GOBIN:"* ]] && export PATH=$GOBIN:$PATH

  export GO111MODULE=on

  # Print all GO env variables
  go env
}

# ------------------------------------------

function install_local_terraform() {
  # Installing Terraform with Anaconda (https://anaconda.org/conda-forge/terraform)
  # trap_commands
  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  echo "# Installing a local Terraform on user \"$(whoami)\" home directory, with Anaconda"
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge terraform
  conda list
}

# ------------------------------------------

# Docker with Anaconda is not supported in Linux yet
function install_local_docker() {
  # Installing Docker with Anaconda (https://anaconda.org/conda-forge/docker)
  # trap_commands
  # curl -o /etc/yum.repos.d/vbatts-shadow-utils-newxidmap-epel-7.repo \
  # https://copr.fedorainfracloud.org/coprs/vbatts/shadow-utils-newxidmap/repo/epel-7/vbatts-shadow-utils-newxidmap-epel-7.repo
  # yum install -y shadow-utils46-newxidmap
  # SKIP_IPTABLES=1 curl -fsSL https://get.docker.com/rootless | sh -s -- --experimental
  # # curl -fsSL https://get.docker.com/rootless | sh -s -- --iptables=false

  install_dir="${1:-.}/"
  install_anaconda "${install_dir}"

  echo "# Installing a local Docker on user \"$(whoami)\" home directory, with Anaconda"
  conda config --add channels conda-forge
  source activate $CONDA_ENV_NAME
  conda install -y --update-deps -c conda-forge docker
  conda list
}

# ------------------------------------------

# Function to download file from URL, if local file doesn't exists, or has a different size on URL
function download_file() {
  # trap_commands
  # $1 => $source_file (download link)
  source_file="$1"

  # Optional: $2 => $target_file (where to save)
  target_file=${2:-$(basename "$1")}

  # Optional: $3 = Target FILE_NAME (and source_file is treated as Directory path)
  # if [[ -z "$3" ]]; then
  #   source_file="$1"
  #   FILE_NAME=$(basename "$1")
  # else
  #   source_file="$1/$3"
  #   FILE_NAME=$3
  # fi

  echo "# Downloading [$source_file] into $target_file"
  ls -ld

  local_file_size=$([[ -f ${target_file} ]] && wc -c < ${target_file} || echo "0")
  echo "local_file_size = $local_file_size"
  remote_file_size=$(curl -sI ${source_file} | awk '/Content-Length/ { print $2 }' | tr -d '\r' )
  echo "remote_file_size = $remote_file_size"
  [[ -n "$remote_file_size" ]] || remote_file_size=-1
  if [[ "$local_file_size" -ne "$remote_file_size" ]]; then
      echo "# Requested file was not downloaded yet, or remote file size is different. Downloading..."
      rm -rf "$target_file"
      if [[ $(which wget) ]] ; then
        target_dir=$(dirname -- "$target_file")
        wget "$source_file" --no-verbose --no-check-certificate --directory-prefix="$target_dir"
        source_file=$(basename -- "$source_file")
        mv "$target_dir/$source_file" "$target_file" || :
      else
        echo "# Wget is not installed, using Curl instead."
        curl -L "$source_file" -o "$target_file" --create-dirs
      fi
  else
    echo "# $target_file already downloaded, and equals to remote file $source_file"
  fi
}

# ------------------------------------------

# Function to delete files/directories which were not accessed N days (no recursive search in sub directories)
function delete_old_files_or_dirs() {
  # trap_commands
  # $1 => $wildcard_name
  wildcard_name="$1"

  # Optional: $2 => $dir_or_file. f=file, d=directory (default)
  dir_or_file="${2:-f}"

  # Optional: $3 => $access_days (5 default)
  access_days="${3:-5}"

  # Set $search_path as parent directory of $wildcard_name, if it includes slashes (current path by default)
  search_path=$(dirname -- "$wildcard_name")

  # Set $search_name as base directory of $wildcard_name, if it includes slashes
  search_name=$(basename -- "$wildcard_name")

  # find "$search_path"/* -maxdepth 0 -type $dir_or_file -name "$search_name" -atime +${access_days} -print -delete
  find "$search_path"/* -maxdepth 0 -type $dir_or_file -name "$search_name" -atime +${access_days} | xargs -n1 --verbose rm -rf
}

# ------------------------------------------

# Function to move non-empty directory to an existing directory
function backup_and_remove_dir() {
  # $1 => $src_dir
  src_dir="$1"

  # Optional: $2 => $dest_dir
  dest_dir="${2:-_$1}"

  if [[ ! -d ${src_dir} ]] || [[ -z `ls -A "$src_dir"` ]] ; then
    echo "# Source directory [${src_dir}] doesn't exist (or empty). Skipping backup"
  else
    echo "# Backup directory [${src_dir}] into [${dest_dir}]"

    # Make a new directory (skip if exists)
    mkdir -p "$dest_dir"

    # Copy * from src_dir to dest_dir (-afr : Keep attributes, Force overwrite, Recursive copy)
    cp -afr "${src_dir}"/. "${dest_dir}"/

    # Force remove old directory
    lsof +D "$src_dir" | awk '{print $2}' | tail -n +2 | xargs --no-run-if-empty kill -9
    rm -rf "$src_dir"
  fi
}

# ------------------------------------------

# Function to install aws-cli, and to configure AWS access:
function configure_aws_access() {
  AWS_PROFILE_NAME="$1"
  AWS_REGION="$2"
  AWS_KEY="$3"
  AWS_SECRET="$4"
  install_dir="${5:-./}"
  aws_bin_dir="${6:-$HOME/.local/bin}"

  PROMPT "Installing AWS-CLI, and setting Profile [$AWS_PROFILE_NAME] and Region [$AWS_REGION]"
  # pip install awscli --upgrade --user
  aws_cli_installer="awscli-exe-linux-x86_64.zip"
  download_file "https://awscli.amazonaws.com/${aws_cli_installer}" "${install_dir}/${aws_cli_installer}"
  unzip -n "${install_dir}/${aws_cli_installer}" -d "${install_dir}"

  # export PATH=$HOME/.local/bin:$PATH
  # ${install_dir}/aws/install --update --install-dir ~/.local --bin-dir ~/.local/bin
  [[ ":$PATH:" != *":${aws_bin_dir}:"* ]] && export PATH="${PATH}:${aws_bin_dir}"
  ${install_dir}/aws/install --update --install-dir "${install_dir}/aws" --bin-dir "${aws_bin_dir}"

  aws --version

  aws configure set profile $AWS_PROFILE_NAME
  aws configure set aws_access_key_id $AWS_KEY
  aws configure set aws_secret_access_key $AWS_SECRET

  aws configure set default.region $AWS_REGION
  aws configure set output text
  aws configure set color on

  # aws --profile "$AWS_PROFILE_NAME" configure  --region "$AWS_REGION" --output text --color on
  aws sts get-caller-identity
}

# ------------------------------------------

# Function to create json file for a DNS record deletion on AWS
function create_json_for_dns_delete() {
  # Input $1 : File to write the json output to
  (
  cat <<EOF
  {
      "Comment": "Delete single record set",
      "Changes": [
          {
              "Action": "DELETE",
              "ResourceRecordSet": {
                  "Name": "$(echo ${Name/\\052/*})",
                  "Type": "$Type",
                  "AliasTarget": {
                    "HostedZoneId": "$HostedZoneId",
                    "DNSName": "$DNSName",
                    "EvaluateTargetHealth": $EvaluateTargetHealth
                    }}
                }]
    }
EOF
  ) > $1
}

# ------------------------------------------

# Function to export variables from json file as environment variables
function export_vars_from_json() {
  # Input $1 : Json file to read variables from
  for s in $(grep -E '": [^\{]' "$1" | sed -e 's/: /=/' -e 's/^\s*//' -e "s/\(\,\)$//"); do
    echo "# export $s"
    eval export $s
  done
}

# ------------------------------------------

# Function to delete an DNS record set in AWS Hosted Zone
function delete_aws_dns_records() {
  PROMPT "Deleting DNS record for AWS Cluster A (Public): $2"
  # trap_commands;
  # Input $1 : Hosted Zone ID
  # Input $2 : DNS record-set (name) to delete

  # export PATH=$HOME/.local/bin:$PATH
  # PATH="${PATH}:${aws_install_dir}/bin"
  local tmp_file="`mktemp`_aws_records"

  echo -e "\n# Searching in Hosted Zone [$1] - for a DNS record set: [$2]"
  aws route53 list-resource-record-sets --hosted-zone-id $1 --query "ResourceRecordSets[?Name == '$2']" --out json > "$tmp_file"

  cat $tmp_file

  if [[ $(< $tmp_file) == '[]' ]]; then
    echo -e "The DNS record set does not exist in AWS cluster [${CLUSTER_A_NAME}]"
    return
  fi

  echo -e "\n# Exporting DNS record set variables:"
  export_vars_from_json "$tmp_file"

  echo -e "\n# Creating json file for the DNS record set delete command:"
  create_json_for_dns_delete "$tmp_file"
  cat "$tmp_file"

  echo -e "\n# Deleting the DNS record set:"
  aws route53 change-resource-record-sets --hosted-zone-id $1 --change-batch file://$tmp_file

}

# ------------------------------------------

# Function to delete selcted namespace and CRDs on the current KUBECONFIG cluster
function delete_namespace_and_crds() {
  # trap_commands;
  # Input $1 : Namespace to delete
  # Input $2 - Optional : All CRDs to delete, by searching for *crd_name*
  ns_name=$1
  crd_name=$2
  delete_namespace=FALSE
  delete_crds=FALSE
  force_ns_delete=FALSE

  if [[ -n $crd_name ]] ; then
    echo "# Searching for existing CRDs of previous ${crd_name} installation on the cluster:"
    ${OC} get crds |& highlight "${crd_name}" && delete_crds=TRUE || :

    # If there are existing CRDs on the cluster - remove them all:
    # if [[ $? = 0 ]]; then
    if [[ "$delete_crds" = TRUE ]]; then
      echo "# Deleting ${crd_name} CRDs in the cluster"
      crd_list=$(${OC} get crds -o name | grep -Po "\/\K.*${crd_name}.*")
      # Ignoring hanged CRDs on delete, due to K8s bug: https://github.com/kubernetes/kubernetes/issues/60538
      ${OC} delete --timeout=10s crds $crd_list --ignore-not-found || : # || : to ignore none-zero exit code
          # customresourcedefinition.apiextensions.k8s.io "clusters.submariner.io" deleted
          # customresourcedefinition.apiextensions.k8s.io "endpoints.submariner.io" deleted
          # customresourcedefinition.apiextensions.k8s.io "submariners.submariner.io" deleted
    fi
  fi

    echo "# Searching for existing resources (and OLMs) in namespace ${ns_name} :"
    # ${OC} get all,olm --all-namespaces | grep --color "${crd_name}" || delete_namespace=FALSE
    ${OC} get all,olm -n ${ns_name} |& highlight "No resources found" || :

  # Removing whole namespace (and it's resources):
  if [[ ${ns_name} = "default" ]] ; then
    echo "# Skipping namespace deletion, since it's the \"default\" namespace."
    return
  else
    echo "# Deleting whole namespace ${ns_name} from the cluster"
    ${OC} delete --timeout=30s namespace ${ns_name} --ignore-not-found || force_ns_delete=TRUE

    if [[ "$force_ns_delete" = TRUE && $(${OC} get namespace ${ns_name}) ]]; then
      echo "# Warning: Force delete of namespace via API"
      ${OC} proxy &
      ${OC} get namespace ${ns_name} -o json | jq '.spec = {"finalizers":[]}' > temp.json
      curl -k -H "Content-Type: application/json" -X PUT --data-binary @temp.json 127.0.0.1:8001/api/v1/namespaces/${ns_name}/finalize
      kill -9 %% || :
      ${OC} delete namespace ${ns_name} --ignore-not-found --grace-period=0 --force --wait
    fi
  fi
}


# ------------------------------------------

# Function to install and expose Nginx service on the current KUBECONFIG cluster
function install_nginx_service() {
  trap_commands;

  ngnix_name="${1:-NginX}"
  target_namespace="$2" # The Namespace for Ngnix
  service_params="$3" # e.g. to expose Nginx as headless service on port 8080 pass: " --port=8080 --cluster-ip='' "

  nginx_image="nginxinc/nginx-unprivileged:stable-alpine"

  if [[ -n "$target_namespace" ]] ; then
    echo "# Create Namespace for Nginx: $target_namespace"
    # delete_namespace_and_crds "${target_namespace}"
    ${OC} create namespace "${target_namespace}" || echo "# Existing namespace \"${target_namespace}\" (ignore error)"
  fi

  echo "# Delete and create Nginx Deployment: $target_namespace (using Nginx image \"$nginx_image\")"
  ${OC} delete deployment ${ngnix_name} ${target_namespace:+-n $target_namespace} --ignore-not-found
  ${OC} create deployment ${ngnix_name} ${target_namespace:+-n $target_namespace} --image=$nginx_image

  echo "# Delete and expose Ngnix service:"
  ${OC} delete service ${ngnix_name} ${target_namespace:+-n $target_namespace} --ignore-not-found
  ${OC} expose deployment ${ngnix_name} --name=${ngnix_name} ${service_params} ${target_namespace:+-n $target_namespace}

  echo "# Wait for Ngnix service to be ready:"
  ${OC} rollout status deployment ${ngnix_name} ${target_namespace:+-n $target_namespace}
  ${OC} describe pod ${ngnix_name} ${target_namespace:+-n $target_namespace}

}



# ------------------------------------------

# Function to return (print) the first running pod id, by a label. Exit with FATAL if nothing found.
function get_running_pod_by_label() {
  # Do not trap_command, so it will not be printed as return value
  # set -x
  local pod_label=$1
  local namespace=$2 # Optional: Namespace for the pod
  local tmp_file="`mktemp`_pod_status"

  # Wait up to 3 minutes for the pod to be ready
  ${OC} wait --timeout=3m --for=condition=ready pod ${namespace:+-n $namespace} -l $pod_label > $tmp_file
  pod_status="$(head -1 $tmp_file | awk -F '/| ' '{print $2}' | xargs)"

  # pod_id="$(${OC} get pod ${namespace:+-n $namespace} -l $pod_label --field-selector status.phase=Running | awk 'FNR == 2 {print $1}')"
  # Can also run with: -o jsonpath="{.items[0].metadata.name}"

  # set +x

  #if [[ -n "$(echo $pod_status)" && -n "$(echo $pod_id)" ]] ; then
  if [[ -n "$pod_status" ]]; then
    # echo "$pod_id"
    printf '%s' "$pod_status"
    return 0
  else
    # exit 1
    FATAL "Pod '$pod_label' is not running in '${namespace:-default}' namespace. \n $pod_status"
  fi

}


# ------------------------------------------

# Function to tail pod logs for N times, after each interval
function watch_pod_logs() {
  trap_commands;

  local pod_to_watch="$1"
  local namespace="$2"
  local regex="$3"

  # Optional params:
  local retries=${4:-5}
  local interval=${5:-20s} # time between each retry attempt
  local tmp_file="`mktemp`_pod_log"

  echo -e "# Tailing logs of Pod [$pod_to_watch] in Namespace [$namespace]: \n"

  cmd="${OC} logs --tail -1 --timestamps $pod_to_watch -n $namespace \
  > $tmp_file && grep -E '$regex' -m 1 -C 5 $tmp_file || sleep $interval"

  watch_and_retry "$cmd" "$retries" "$regex"
}

# ------------------------------------------

function print_pod_logs_in_namespace() {
  local namespace="$1"
  local pods_label="${2:+ -l $2}"
  echo -e "\n##################### Pods descriptions and logs${2:+ by label "$2"} in Namespace: ${namespace} #####################\n"

  for pod in $(${OC} get pods $pods_label -n $namespace -o jsonpath='{.items[*].metadata.name}'); do
      echo -e "\n### Pod $pod in Namespace $namespace ###\n"
      ${OC} -n $namespace describe pod $pod || :
      ${OC} -n $namespace get pod $pod -o yaml || :
      ${OC} -n $namespace logs $pod --limit-bytes=1000000 || :
  done
}


# ------------------------------------------

# Function to create test case template in Polarion for each Junit testcase
function create_polarion_test_cases_from_junit() {
    trap_commands;

    local polarion_url="$1"
    # polarion_url="https://polarion.stage.engineering.redhat.com/polarion"

    # local polarion_rc="$2" # curl netrc file to access Polarion
    local polarion_auth="$2" # Polarion AUTH=$(echo -ne 'user:password' | base64 --wrap 0)

    local junit_xml="$3"
    local polarion_project_id="$4" # ocp
    local polarion_team_name="$5" # Multi-Cluster-Networking

    local tc_list="`mktemp`_testcases"

    echo -e "### Creating Polarion test-cases template (xml) for Junit results: $junit_xml
    \n# Polarion project: [${polarion_project_id}], team name: [${polarion_team_name}]"

    # Verify junit file exists
    [[ -s "$junit_xml" ]] || ( echo "Failed to create Polarion test-cases file: '$junit_xml' is missing." && return 1 )

    # Output file for Polarion test-cases, should be without "junit" substring in file name
    local polarion_testcases_filepath="${junit_xml%%.*}_polarion_testcases.xml"
    tc_xml_name="$(basename "${polarion_testcases_filepath}")"
    polarion_testcases_filepath="$(dirname "${polarion_testcases_filepath}")/${tc_xml_name//junit}"

    # cat $junit_xml | grep "<testcase " | grep -oE "name=\".+\" " | cut -d '"' -f 2 > $tc_list
    cat $junit_xml | grep -oP '<testcase.* name="\K[^"]+' | cut -d ':' -f 2 > $tc_list

    echo -e "<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n\
    <testcases project-id=\"${polarion_project_id}\" document-relative-path=\"${polarion_team_name}/${polarion_team_name} Test Cases\">  \n\
      <properties>  \n\
          <property name=\"lookup-method\" value=\"name\"/>  \n\
      </properties>" > "$polarion_testcases_filepath"

    while read line ; do
      echo "<testcase approver-ids=\"achernet:approved\" status-id=\"draft\">
          <title>$line</title>
            <description>$line</description>
            <custom-fields>
              <custom-field content=\"${polarion_team_name}\" id=\"subteam\"/>
              <custom-field content=\"functional\" id=\"testtype\"/>
              <custom-field content=\"ocp\" id=\"products\"/>
            </custom-fields>
        </testcase>
        " >> "$polarion_testcases_filepath"
      done < "$tc_list"

      echo "</testcases>" >> "$polarion_testcases_filepath"

      curl -k --header "Authorization: Basic $polarion_auth" -X POST -F file=@${polarion_testcases_filepath} ${polarion_url}/import/testcase

}


# ------------------------------------------

# Function to create Polarion test run (xml) from Junit
function create_polarion_test_run_from_junit() {
    trap_commands;

    local polarion_url="$1"
    # polarion_url="https://polarion.stage.engineering.redhat.com/polarion"

    # local polarion_rc="$2" # curl netrc file to access Polarion
    local polarion_auth="$2" # Polarion AUTH=$(echo -ne 'user:password' | base64 --wrap 0)

    local junit_xml="$3"
    local polarion_project_id="$4"
    # local polarion_testrun_id="$3"
    local polarion_team_name="$5"
    local polarion_testrun_title="$6"

    local sed_expression

    echo -e "### Creating Polarion test-run (xml) for Junit results: $junit_xml
    \n# Polarion project: [${polarion_project_id}], team name: [${polarion_team_name}]"

    # Verify junit file exists
    [[ -s "$junit_xml" ]] || ( echo "Failed to create Polarion test-run file: '$junit_xml' is missing." && return 1 )

    # Create Polarion test run results (without "junit" substring in xml file name)
    local polarion_testrun_filepath="${junit_xml%%.*}"
    local tr_xml_name="$(basename "${polarion_testrun_filepath}")"

    polarion_testrun_title="${polarion_testrun_title:-${tr_xml_name%%.*} - $polarion_team_name Test Run}"
    local polarion_testrun_id="${polarion_testrun_title//[^[:alnum:]]/_}"

    polarion_testrun_filepath="$(dirname "${polarion_testrun_filepath}")/${tr_xml_name//junit}_polarion_testrun.xml"

    echo -e "### Polarion Test-run Title: [${polarion_testrun_title}],
    \n# Polarion Test-run file [${polarion_testrun_filepath}] \n"

    cp "$junit_xml" "$polarion_testrun_filepath"

    echo "# Add <testsuites> with Polarion project id: [${polarion_project_id}], team name: [${polarion_team_name}]"

    # Remove first <testsuiteS> tag (if exists):
    sed -e '0,/<testsuites>/s/<testsuites>//' -i "$polarion_testrun_filepath"
    # sed -r "s:<testsuites>::" -i "$polarion_testrun_filepath"

    # Define Polarion <testsuites> properties:
    polarion_suite_content="<testsuites> \n\
        <properties> \n\
            <property name=\"polarion-project-id\" value=\"$polarion_project_id\" /> \n\
            <property name=\"polarion-response-myteamsname\" value=\"$polarion_team_name\" /> \n\
            <property name=\"polarion-lookup-method\" value=\"name\" /> \n\
            <property name=\"polarion-testrun-title\" value=\"$polarion_testrun_title\" /> \n\
            <property name=\"polarion-testrun-id\" value=\"$polarion_testrun_id\" /> \n\
            <property name=\"polarion-testrun-status-id\" value=\"inprogress\" /> \n\
        </properties> \n\
    <testsuite "

    # Removed: <property name=\"polarion-testrun-id\" value=\"$polarion_testrun_id\" /> \n\
    # Removed: <property name=\"polarion-testrun-template-id\" value=\"Build Acceptance type\" /> \n\

    sed_expression="0,/<testsuite /s,<testsuite ,$polarion_suite_content,"

    # Insert this <testsuiteS> properties instead of the first <testsuite> tag:
    sed -r "$sed_expression" -i "$polarion_testrun_filepath"

    # Remove last </testsuiteS> tag (if exists):
    sed -r -z "s:(.*)</testsuites>(.*):\1\2:" -i "$polarion_testrun_filepath"

    # Add </testsuiteS> tag, after the last </testsuite> tag:
    sed -r -z 's:(.*</testsuite>):\1\n</testsuites>:' -i "$polarion_testrun_filepath"

    # ------------------------------------------------------------------------ #

    echo "# Add <testcase> with Polarion test-run title: $polarion_testrun_title"

    # Define Polarion <testcase> property:
    polarion_testcase_content="\n\
        <properties> \n\
            <property name=\"polarion-testcase-comment\" value=\"$polarion_testrun_title\" /> \n\
        </properties> \n\
    </testcase>"

    # polarion_testcase_content="\n\
    #     <properties> \n\
    #         <property name=\"polarion-testrun-id\" value=\"$polarion_testrun_id\" /> \n\
    #     </properties> \n\
    # </testcase>"

    sed_expression="s:</testcase>:$polarion_testcase_content:g"

    # Insert the property instead of EACH testcase tag
    sed -r "$sed_expression" -i "$polarion_testrun_filepath"

    curl -k --header "Authorization: Basic $polarion_auth" -X POST -F file=@${polarion_testrun_filepath} ${polarion_url}/import/xunit

}

# ------------------------------------------

function log_to_html() {
  # trap_commands;
  log_file="$1"
  title="${2:-"${log_file%%.*}"}" # full file path without extension
  html_output="${3:-${title// /_}.html}" # replace all spaces with underscores

  echo "# Generating HTML report from: $log_file"
  [[ -f $log_file ]] || ( echo "# Error - The file does not exists, or is not accessible" && return 1 )
  repo_url=https://github.com/theZiz/aha.git
  repo_branch=0.5
  repo_dir=$(basename $repo_url .git)

  # Get AHA binary
  if [[ ! -f ./$repo_dir/aha ]]; then
      rm -rf $repo_dir
      # git clone --quiet --branch "$repo_branch" $repo_url > /dev/null
      git clone $repo_url --single-branch # --depth 1
      git --work-tree=$repo_dir  --git-dir=$repo_dir/.git checkout tags/$repo_branch
      make -C $repo_dir &> /dev/null
  fi
  ./$repo_dir/aha --version

  # Create HTML Header
  cat > "$html_output" <<EOF
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <meta http-equiv="Content-Type" content="application/xml+xhtml; charset=UTF-8; width=device-width; initial-scale=1" />
  <title>${title}</title>
  <style type="text/css">
  pre {white-space: pre-wrap; white-space: -moz-pre-wrap !important;
  white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;}
  .collapsible {
    background-color: LightSkyBlue;
    color: black;
    cursor: pointer;
    padding: 10px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 20px;
    -webkit-touch-callout: text;
    -webkit-user-select: text;
    -khtml-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
  }
  .active {
    background-color: RoyalBlue;
    color: white;
  }
  .collapsible:hover {
    background-color: RoyalBlue;
    color: white;
    text-decoration: underline;
  }
  .content {
    padding: 0 18px;
    display: none;
    overflow: hidden;
    background-color: LightSkyBlue;
  }
  </style>
  </head>
  <body style="background-color:LightSkyBlue">
  <h1>${title}</h1>
  <pre>
EOF

  # Trim empty lines (from top) and spaces (not tabs) from each line in the log file
  #sed '/\S/,$!d; s/^ \+//; s/ \+$//' -i $log_file
  sed '/\S/,$!d' -i $log_file

  # Create HTML content with AHA
  ./$repo_dir/aha -f $log_file --title "$title" --word-wrap --no-header >> $html_output

  # Replace all lines of "<span...### {text...} ###</span>" - with a collapsible span ("###" was created with "PROMPT" function)
  sed -r 's:<span.+###\s+:<button type="button" class="collapsible"><span>:g' -i $html_output
  sed -r 's:\s+###</span.+$:<\/span><\/button><div class="content">:g' -i $html_output

  # Close all collapsible spans, when getting to lines of ðŸŽ©ï¸Ž (excluding first time)
  sed -r 's:(.+ðŸŽ©ï¸Ž):<\/div><br><br>\1:g' -i $html_output
  sed '0,/<\/div><br><br>/s///' -i $html_output

  # Create HTML collapsible function (must be at the bottom)
  cat >> $html_output <<EOF
  </pre>
  <br><br><br>
  <script>
  var coll = document.getElementsByClassName("collapsible");
  var i;
  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
  </script>
  </body>
  </html>
EOF

  echo -e "HTML report created:\n$html_output"
}
